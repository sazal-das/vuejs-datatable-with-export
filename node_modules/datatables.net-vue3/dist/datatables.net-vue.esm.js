import { defineComponent, setBlockTracking, createElementVNode, normalizeClass, renderSlot } from 'vue';

var DataTablesLib;
const Comp = defineComponent({
  name: 'DataTable',
  expose: ['dt'],

  data() {
    return {
      _dt: null,
      oldData: []
    };
  },

  computed: {},
  methods: {
    dt() {
      return this._dt;
    },

    saveOld(d) {
      this.oldData = d.value ? d.value.slice() : d.slice();
    }

  },

  mounted() {
    // Component shown so we can initialise DataTables of the table now
    let table = this.$el.querySelector('table');
    let options = this.options;

    if (this.data) {
      options.data = this.data;
      this.saveOld(options.data);
    }

    if (this.columns) {
      options.columns = this.columns;
    }

    if (this.ajax) {
      options.ajax = this.ajax;
    }

    if (!DataTablesLib) {
      throw new Error('DataTables library not set. See https://datatables.net/tn/19 for details.');
    }

    this._dt = new DataTablesLib(table, options);
  },

  beforeUnmount() {
    this._dt.destroy(true);
  },

  props: {
    ajax: null,
    class: {
      type: String,
      default: ''
    },
    columns: {
      type: Array,
      default: null
    },
    data: {
      type: Array,
      default: null
    },
    options: {
      default: {}
    }
  },
  watch: {
    data: {
      handler(newVal) {
        let known = this._dt.data().toArray(); // Find any new rows


        for (let n of newVal) {
          if (!known.includes(n)) {
            this._dt.row.add(n);
          }
        } // Remove any old rows


        for (let k of known) {
          if (!newVal.includes(k)) {
            this._dt.row((_idx, d) => d === k).remove();
          }
        } // Data in other rows might have changes, so we need to invalidate the rows


        this._dt.rows().invalidate().draw(false);

        this.saveOld(newVal);
      },

      deep: true
    }
  }
}); // Expose a static method that can be used to add extensions

Comp.use = function (lib) {
  DataTablesLib = lib;
};

var script = Comp;

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return _cache[0] || (setBlockTracking(-1), _cache[0] = createElementVNode("div", {
    class: "datatable"
  }, [createElementVNode("table", {
    class: normalizeClass(_ctx.class)
  }, [renderSlot(_ctx.$slots, "default")], 2)]), setBlockTracking(1), _cache[0]);
}

script.render = render;

// Import vue component
// IIFE injects install function into component, allowing component
// to be registered via Vue.use() as well as Vue.component(),

var entry_esm = /*#__PURE__*/(() => {
  // Assign InstallableComponent type
  const installable = script; // Attach install function executed by Vue.use()

  installable.install = app => {
    app.component('Datatables.netVue', installable);
  };

  return installable;
})(); // It's possible to expose named exports when writing components that can
// also be used as directives, etc. - eg. import { RollupDemoDirective } from 'rollup-demo';
// export const RollupDemoDirective = directive;

export { entry_esm as default };
